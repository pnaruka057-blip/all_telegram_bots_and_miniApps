<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src='//libtl.com/sdk.js' data-zone='9690148' data-sdk='show_9690148'></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script async src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script>
        window.addEventListener("DOMContentLoaded", async () => {
            const tg = window.Telegram.WebApp;
            tg.ready();
            tg.expand();

            const user = tg.initDataUnsafe?.user;
            let startParamRaw = tg.initDataUnsafe?.start_param;

            // show something so user isn't stuck on blank screen
            const status = document.createElement('div');
            status.style.color = '#fff';
            status.style.padding = '16px';
            status.style.textAlign = 'center';
            status.style.fontSize = '14px';
            document.body.prepend(status);

            if (!user) {
                document.body.innerHTML = '<div class="text-center mt-10 text-red-600 text-lg">Please open inside Telegram</div>';
                return;
            }

            if (!startParamRaw) {
                status.textContent = 'No start_param present.';
                console.warn('No start_param:', tg.initDataUnsafe);
                return;
            }

            status.textContent = 'start_param found â€” parsing...';

            // we'll attempt several decoding strategies in order
            const attempts = [];

            // 1) raw as-is
            attempts.push({ desc: 'raw', value: startParamRaw });

            // 2) decodeURIComponent (common)
            try { attempts.push({ desc: 'decodeURIComponent', value: decodeURIComponent(startParamRaw) }); } catch (e) { }

            // 3) try one extra decode (some clients double-encode)
            try { attempts.push({ desc: 'decodeURIComponent x2', value: decodeURIComponent(decodeURIComponent(startParamRaw)) }); } catch (e) { }

            // 4) treat as base64 (URL-decoded first)
            try {
                const asDecoded = decodeURIComponent(startParamRaw);
                const b = atob(asDecoded); // atob works on base64; wrap in try/catch
                attempts.push({ desc: 'base64(decodeURIComponent->atob)', value: b });
            } catch (e) { }

            // 5) treat raw as base64 (some flows may give raw base64)
            try {
                const b2 = atob(startParamRaw);
                attempts.push({ desc: 'base64(raw)->atob', value: b2 });
            } catch (e) { }

            // 6) try JSON parse attempts (for JSON-string payload)
            for (const a of [...attempts]) {
                try {
                    const maybe = JSON.parse(a.value);
                    attempts.push({ desc: `json(${a.desc})`, value: maybe });
                } catch (e) { }
            }

            attempts.forEach((it, idx) => console.log(idx, it.desc, it.value));
            console.groupEnd();

            // try to extract token/app/page from attempts
            function tryExtract(value) {
                if (!value) return null;

                // if value is object from JSON parse
                if (typeof value === 'object') {
                    // expected key names if JSON used
                    if (value.t && value.a && value.p) {
                        return { token: value.t, app: value.a, page: value.p };
                    }
                    // fallback keys
                    if (value.token && value.app && value.page) {
                        return { token: value.token, app: value.app, page: value.page };
                    }
                    return null;
                }

                // if string, accept both colon and pipe or slash separators
                if (typeof value === 'string') {
                    let s = value.trim();

                    // replace url-encoded separators if any lingering
                    s = s.replace(/%3A/gi, ':').replace(/%7C/gi, '|');

                    // common separators to try
                    const sepCandidates = [':', '|', '/', '::'];

                    for (const sep of sepCandidates) {
                        if (s.indexOf(sep) !== -1) {
                            const parts = s.split(sep).map(p => p.trim());
                            // token:app:page  => length >=3
                            if (parts.length >= 3) {
                                return { token: parts[0], app: parts[1], page: parts[2] };
                            }
                        }
                    }

                    // fallback: space-separated
                    const sp = s.split(' ').filter(Boolean);
                    if (sp.length >= 3) return { token: sp[0], app: sp[1], page: sp[2] };
                }

                return null;
            }

            // iterate attempts in priority order, pick first valid extraction
            let extracted = null;
            for (const it of attempts) {
                const result = tryExtract(it.value);
                if (result) {
                    extracted = { ...result, _source: it.desc, _raw: it.value };
                    break;
                }
            }

            if (!extracted) {
                status.textContent = 'Start param found but could not parse token/app/page. Check console.';
                return;
            }

            // safety check
            if (extracted.app !== 'group-help-advance') {
                status.textContent = `App mismatch: ${extracted.app}`;
                console.warn('App name mismatch, expected group-help-advance, got:', extracted.app);
                return;
            }

            status.textContent = 'Redirecting...';
            // final redirect (use replace to avoid history clutter)
            window.location.replace(`/${extracted.token}/${extracted.app}/${extracted.page}`);
        });
    </script>
    <style>
        .hidden {
            display: none;
        }

        @keyframes gradientShift {
            0% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }

            100% {
                background-position: 0% 50%;
            }
        }

        .animate-background {
            background: linear-gradient(-45deg, #e6faff, #5da6ff, #e6faff, #5da6ff);
            background-size: 400% 400%;
            animation: gradientShift 4s ease infinite;
        }
    </style>
</head>

<body class="bg-gray-800 flex justify-center items-center select-none">
    <!-- Page Loader -->
    <div id="pageLoader"
        class="fixed inset-0 bg-black/60 backdrop-blur-sm z-[9999] flex items-center justify-center hidden">
        <div class="flex space-x-2">
            <div class="w-3 h-3 bg-white rounded-full animate-bounce [animation-delay:0s]"></div>
            <div class="w-3 h-3 bg-white rounded-full animate-bounce [animation-delay:0.2s]"></div>
            <div class="w-3 h-3 bg-white rounded-full animate-bounce [animation-delay:0.4s]"></div>
        </div>
    </div>

    <%- body %> <!-- dynamic page content -->

        <script>
            // Show loader on every internal anchor tag click
            document.querySelectorAll("a").forEach(link => {
                link.addEventListener("click", function (e) {
                    const href = link.getAttribute("href");
                    if (href && !href.startsWith("http") && !href.startsWith("#") && !link.hasAttribute("target")) {
                        document.getElementById("pageLoader").classList.remove("hidden");
                    }
                });
            });
        </script>
</body>
<script>

</script>

</html>